<?php
/**
 * @file
 *   Commerce Registration module code.
 */

/**
 * Implements hook_menu().
 */
function commerce_registration_menu() {
  $menu = array();

  $menu['node/%node/registration'] = array(
    'title' => 'Registrations',
    'access callback' => 'commerce_registration_registration_page_access',
    'access arguments' => array(1),
    'page callback' => 'commerce_registration_registration_page',
    'page arguments' => array(1),
    'type' => MENU_LOCAL_TASK,
  );

  return $menu;
}

/**
 * Page access callback to view all registrations for a given product display.
 * @todo Registration function to check if a given entity is register
 *   enabled.
 */
function commerce_registration_registration_page_access($node) {
  if (isset($node->field_commerce_product)) {
    foreach ($node->field_commerce_product[LANGUAGE_NONE] as $product) {
      $prod = commerce_product_load($product['product_id']);
      $status = registration_entity_registration_status('commerce_product', $prod->type, $product['product_id']);
      $bundle = registration_entity_registration_bundle('commerce_product', $prod->type, $product['product_id']);
      if ($status == 1 && $bundle != '' && (user_access('view any registration') || user_access('view ' . $bundle . ' registration'))) {
        return TRUE;
      }
    }
  }
  return FALSE;
}

/**
 * Registration page callback for all registrations for a given product display.
 */
function commerce_registration_registration_page($node) {
  $prodids = array();
  foreach ($node->field_commerce_product[LANGUAGE_NONE] as $product) {
    $prodids[] = (int) $product['product_id'];
  }
  $header = array(t('Order'), t('Date'), t('Product'), t('Registrant'));
  $rows = array();
  foreach ($prodids as $product_id) {
    $reg = db_select('registration', 'r')->fields('r', array('registration_id', 'order_id', 'created', 'author_uid', 'user_uid'));
    $reg->condition('r.entity_type', 'commerce_product')
      ->condition('r.eid', $product_id)
      ->condition('r.status', 1)
      ->condition('r.order_id', 0, '!=')
      ->orderBy('r.created', 'DESC');
    $reg = $reg->execute();
    foreach ($reg as $row) {
      $prod = commerce_product_load($product_id);
      $registrant = user_load($row->user_uid);
      $rows[] = array(
        l(t('Order #') . $row->order_id, 'user/' . $row->author_uid . '/orders/' . $row->order_id),
        date("F j, Y - g:i:s a", $row->created),
        $prod->title,
        l('#' . $row->registration_id . ': ' . $registrant->name, 'registration/' . $row->registration_id),
      );
    }
  }
  if (empty($rows)) {
    $rows[] = array(
      array(
        'data' => t('There are no registrations for any products for this node yet.'),
        'colspan' => 4,
      ),
    );
  }
  return theme('table', array('header' => $header, 'rows' => $rows));
}

/**
 * Implements hook_commerce_checkout_page_info().
 */
function commerce_registration_commerce_checkout_page_info() {
  $pages = array();
  $pages['registration'] = array(
    'name' => t('Registration'),
    'title' => t('Registration Information'),
    'weight' => 5,
    'status_cart' => TRUE,
    'buttons' => TRUE,
  );
  return $pages;
}
/**
 * Implements hook_commerce_checkout_pane_info().
 */
function commerce_registration_commerce_checkout_pane_info() {
  $panes = array();
  $panes['registration_information'] = array(
    'title' => t('Registration Information'),
    'base' => 'commerce_registration_information',
    'page' => 'registration',
    'enabled' => TRUE,
    'weight' => -50,
    'review' => TRUE,
    'file' => 'includes/commerce_registration.checkout_pane.inc',
  );
  return $panes;
}

/**
 * Implements hook_commerce_line_item_type_info().
 */
function commerce_registration_commerce_line_item_type_info() {
  $items = array();

  $items['waitlist'] = array(
    'type' => 'waitlist',
    'name' => t('Waitlist'),
    'product' => TRUE,
    'description' => t('References a product that is out of stock or beyond registration capacity.'),
    'add_form_submit_value' => t('Add product to waitlist'),
    'base' => 'commerce_registration_waitlist',
    'callbacks' => array(
      'title' => 'commerce_registration_waitlist_title',
    ),
  );

  return $items;
}

function commerce_registration_commerce_line_item_type_info_alter(&$line_item_types) {
  $line_item_types['product']['callbacks']['title'] = 'commerce_registration_product_title';
}

/**
 * Line item configuration callback.
 */
function commerce_registration_waitlist_configuration() {
  
}

/**
 * Product title line item callback.
 *
 * We alter the title of the default line item to show available slots if the
 * product is register enabled.
 *
 * @param $line_item
 *
 * @return
 *   Title of the line item product plus available slots, if applicable.
 */
function commerce_registration_product_title($line_item) {
  $line_item_wrapper = entity_metadata_wrapper('commerce_line_item', $line_item);
  return commerce_registration_get_product_title($line_item_wrapper->commerce_product->value());
}

/**
 * Returns a product title.
 *
 * @param $product
 *   Fully formed Commerce Product object.
 *
 * @return
 *   Product title with remaining capacity if available.
 */
function commerce_registration_get_product_title($product) {
  $entity = array(
    'id' => $product->product_id,
    'type' => 'commerce_product',
    'bundle' => $product->type,
  );
  $status = registration_entity_registration_status($entity);
  if ($status == 1) {
    $avail = registration_entity_slots_available($entity);
    $capacity = ($avail != 0 ? format_plural($avail, '1 slot', '@count slots') : 'No slots');
    return t('@title (@capacity available)',
      array(
        '@title' => $product->title,
        '@capacity' => $capacity,
      )
    );
  }
  else {
    return $product->title;
  }
}

/**
 * Line item title callback.
 */
function commerce_registration_waitlist_title($line_item) {
  $line_item_wrapper = entity_metadata_wrapper('commerce_line_item', $line_item);
  $entity = array(
    'id' => $line_item_wrapper->commerce_product->product_id->value(),
    'type' => 'commerce_product',
    'bundle' => $line_item_wrapper->commerce_product->type->value(),
  );
  $avail = registration_entity_slots_available($entity);
  return t('<em>@title (@capacity available) (waitlisted)</em>',
    array(
      '@title' => $line_item_wrapper->commerce_product->title->value(),
      '@capacity' => format_plural($avail, '1 slot', '@count slots'),
    )
  );
}

/**
 * Line item add form callback.
 */
function commerce_registration_waitlist_add_form(&$form_state) {
  
}

/**
 * Line item item add form submit callback.
 */
function commerce_registration_waitlist_add_form_submit(&$line_item, $element, &$form_state, $form) {
  
}

/**
 * Implements hook_form_alter().
 *
 * Changes the product title in the add to cart form to have the remaining
 * capacity if available.
 */
function commerce_registration_form_alter(&$form, &$form_state, $form_id) {
  if (substr($form_id, 0, 30) == 'commerce_cart_add_to_cart_form') {
    switch ($form['product_id']['#type']) {
      case "select":
        $products = $form['product_id']['#options'];
        foreach ($products as $product_id => $title) {
          $product = commerce_product_load($product_id);
          $title = commerce_registration_get_product_title($product);
          $form['product_id']['#options'][$product_id] = $title;
        }
        break;
      case "hidden":
        $product = commerce_product_load($form['product_id']['#value']);
        $entity = array(
          'id' => $product->product_id,
          'type' => 'commerce_product',
          'bundle' => $product->type,
        );
        $submit = $form['submit'];
        unset($form['submit']);
        $capacity = registration_entity_slots_available($entity);
        $capacity = ($capacity != 0 ? format_plural($capacity, '1 slot available', '@count slots available') : t('No slots available (waitlist only)'));
        $form['capacity'] = array(
          '#type' => 'markup',
          '#markup' => '<em>' . $capacity . '</em>',
        );
        $form['submit'] = $submit;
        break;
    }
  }
}