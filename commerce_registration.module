<?php
/**
 * @file
 * Commerce Registration module code.
 */

/**
 * Implements hook_menu().
 */
function commerce_registration_menu() {
  $menu = array();

  $menu['node/%node/registration'] = array(
    'title' => 'Registrations',
    'access callback' => 'commerce_registration_registration_page_access',
    'access arguments' => array(1),
    'page callback' => 'commerce_registration_registration_page',
    'page arguments' => array(1),
    'type' => MENU_LOCAL_TASK,
  );

  $menu['admin/commerce/registrations'] = array(
    'title' => 'Registrations',
    'description' => 'Manage product registrations that have been purchased.',
    'access arguments' => array('administer registration'),
    'page callback' => 'commerce_registration_admin_overview',
    'file' => 'includes/commerce_registration.admin.inc',
  );

  return $menu;
}

/**
 * Page access callback to view all registrations for a given product display.
 * @todo Registration function to check if a given entity is register
 *   enabled.
 */
function commerce_registration_registration_page_access($node) {
  $fields = field_read_fields(array('type' => 'commerce_product_reference'));
  foreach ($fields as $field) {
    if (isset($node->{$field['field_name']})) {
      foreach ($node->{$field['field_name']} as $product) {
        $settings = registration_entity_settings($product[0]['product_id'], 'commerce_product');
        if (!empty($settings) && user_access('view registration')) {
          return TRUE;
        }
      }
    }
  }
  return FALSE;
}

/**
 * Registration page callback for all registrations for a given product display.
 */
function commerce_registration_registration_page($node) {
  $prodids = array();
  $fields = field_read_fields(array('type' => 'commerce_product_reference'));
  foreach ($fields as $field) {
    if (isset($node->{$field['field_name']})) {
      foreach ($node->{$field['field_name']} as $product) {
        $prodids[] = (int) $product[0]['product_id'];
      }
    }
  }
  $out = "";
  foreach ($prodids as $product_id) {
    $prod = commerce_product_load($product_id);
    $out .= registration_registrations_page('commerce_product', $prod);
  }
  return $out;
}

/**
 * Implements hook_commerce_checkout_page_info().
 */
function commerce_registration_commerce_checkout_page_info() {
  $pages = array();
  $pages['registration'] = array(
    'name' => t('Registration'),
    'title' => t('Registration Information'),
    'weight' => 5,
    'status_cart' => TRUE,
    'buttons' => TRUE,
  );
  return $pages;
}
/**
 * Implements hook_commerce_checkout_pane_info().
 */
function commerce_registration_commerce_checkout_pane_info() {
  $panes = array();
  $panes['registration_information'] = array(
    'title' => t('Registration Information'),
    'base' => 'commerce_registration_information',
    'page' => 'registration',
    'enabled' => TRUE,
    'weight' => -50,
    'review' => TRUE,
    'file' => 'includes/commerce_registration.checkout_pane.inc',
  );
  return $panes;
}

/**
 * Implements hook_commerce_line_item_type_info_alter().
 */
function commerce_registration_commerce_line_item_type_info_alter(&$line_item_types) {
  $line_item_types['product']['callbacks']['title'] = 'commerce_registration_product_title';
}

/**
 * Product title line item callback.
 *
 * We alter the title of the default line item to show available slots if the
 * product is register enabled.
 *
 * @param CommerceLineItem $line_item
 *   The line item to get the title for.
 *
 * @return string
 *   Title of the line item product plus available slots, if applicable.
 */
function commerce_registration_product_title($line_item) {
  $line_item_wrapper = entity_metadata_wrapper('commerce_line_item', $line_item);
  return commerce_registration_get_product_title($line_item_wrapper->commerce_product->value());
}

/**
 * Returns a product title.
 *
 * @param CommerceProduct $product
 *   Fully formed Commerce Product object.
 *
 * @return string
 *   Product title with remaining capacity if available.
 */
function commerce_registration_get_product_title($product) {
  $settings = registration_entity_settings($product->product_id, 'commerce_product');
  if (!empty($settings) && $settings['status'] == 1) {
    $capacity = (int) $settings['capacity'];
    $filled = (int) registration_event_count($product->product_id, 'commerce_product');
    $avail = $capacity - $filled;
    $availtext = ($avail > 0 ? format_plural($avail, '1 slot available', '@count slots available') : 'No slots available');
    $capacitytext = ($capacity == 0 ? t("Unlimited slots available") : $availtext);
    return t('@title (@capacity)',
      array(
        '@title' => $product->title,
        '@capacity' => $capacitytext,
      )
    );
  }
  return $product->title;
}

/**
 * Implements hook_form_alter().
 *
 * Changes the product title in the add to cart form to have the remaining
 * capacity if available.
 */
function commerce_registration_form_alter(&$form, &$form_state, $form_id) {
  // Add slots available text to Add to Cart form.
  if (substr($form_id, 0, 30) == 'commerce_cart_add_to_cart_form') {
    switch ($form['product_id']['#type']) {
      case "select":
        $products = $form['product_id']['#options'];
        foreach ($products as $product_id => $title) {
          $product = commerce_product_load($product_id);
          $title = commerce_registration_get_product_title($product);
          $form['product_id']['#options'][$product_id] = $title;
        }
        break;

      case "hidden":
        $product = commerce_product_load($form['product_id']['#value']);
        $settings = registration_entity_settings($product->product_id, 'commerce_product');
        if (!empty($settings) && $settings['status'] == 1) {
          $submit = $form['submit'];
          unset($form['submit']);
          $capacity = (int) $settings['capacity'];
          $avail = $capacity - registration_event_count($product->product_id, 'commerce_product');
          $availtext = ($avail > 0 ? format_plural($avail, '1 slot available', '@count slots available') : t('No slots available'));
          $capacity = ($settings['capacity'] == 0 ? t("Unlimited slots available") : $availtext);
          $form['capacity'] = array(
            '#type' => 'markup',
            '#markup' => '<em>' . $capacity . '</em>',
          );
          if (registration_has_room($product->product_id, 'commerce_product')) {
            $form['submit'] = $submit;
          }
          else {
            $form['not_available'] = array(
              '#type' => 'markup',
              '#markup' => '<p><strong>' . t('This item is currently unavailable.') . '</strong></p>',
            );
          }
        }
        break;

    }
  }
  elseif (substr($form_id, 0, 32) == 'commerce_product_ui_product_form') {
    // Add settings to Commerce Product Add/Edit Form.
    $product = $form_state['commerce_product'];
    if (!function_exists("registration_registrations_settings_form")) {
      module_load_include("inc", "registration", "/includes/registration.forms");
    }
    if (!function_exists("commerce_registration_registrations_settings_form_validate")) {
      module_load_include("inc", "commerce_registration", "/includes/commerce_registration.forms");
    }
    // Add validation and submission handlers to the form.
    $form['#validate'][] = "commerce_registration_registration_settings_form_validate";
    $form['actions']['submit']['#submit'][] = "commerce_registration_registration_settings_form_submit";
    $form['registration_settings'] = array(
      '#title' => t('Registration Settings'),
      '#type' => "fieldset",
      '#collapsible' => TRUE,
      '#collapsed' => FALSE,
      '#weight' => 45,
    );
    // Grab the registration settings form for this entity.
    $addform = registration_registrations_settings_form(array(), $form_state, "commerce_product", $product);
    // Remove the save button for this form since we have one already.
    unset($addform['save']);
    // We rename the registration settings form's status field to be reg_status
    // so our validation and submission doesn't overwrite the product's status.
    $addform['reg_status'] = $addform['status'];
    $addform['reg_status']['#weight'] = -20;
    unset($addform['status']);
    // Add parents to each registration setting so we can get the values.
    foreach ($addform as $key => $array) {
      $addform[$key]['#parents'] = array('registration_settings', $key);
    }
    // Add the registration settings form to the base form.
    $form['registration_settings'] += $addform;
  }
}

/**
 * Implements hook_entity_property_info_alter().
 */
function commerce_registration_entity_property_info_alter(&$info) {
  $info['registration']['properties']['order_id'] = array(
    'label' => t('Order ID'),
    'type' => 'integer',
    'description' => t('The order ID associated with this registration.'),
  );
}

/**
 * Implements hook_views_api().
 */
function commerce_registration_views_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'commerce_registration') . '/includes/views',
  );
}

/**
 * Implements hook_field_extra_fields().
 */
function commerce_registration_field_extra_fields() {
  $items = array();
  // Add registration availability display option to each commerce product type.
  foreach (field_info_instances('commerce_product') as $product_bundle_name => $product_fields) {
    foreach ($product_fields as $product_field_name => $product_field) {
      if ($product_field['widget']['module'] == 'registration') {
        $items['commerce_product'][$product_bundle_name]['display']['registration_available'] = array(
          'label' => t('Registration Availability'),
          'description' => t('The Registration availability text next to the product.'),
          'weight' => -1,
        );
      }
    }
  }
  return $items;
}
/**
 * Implements hook_field_extra_fields_alter().
 */
function commerce_registration_field_extra_fields_alter(&$info) {
  // Loop through the product reference fields.
  foreach (commerce_info_fields('commerce_product_reference') as $field_name => $field) {
    foreach ($field['bundles'] as $entity_type => $bundles) {
      if ($entity_type == 'commerce_line_item' || $entity_type == 'commerce_product') {
        // Skip line items and products, don't want to remove these fields.
        continue;
      }
      foreach ($bundles as $bundle_name) {
        $product_fields = commerce_product_field_extra_fields();
        if (empty($product_fields['commerce_product'])) {
          // Skip if there are no commerce product extra fields.
          continue;
        }
        // Loop through each field on the product, and if it's a Registration,
        // hide it.
        foreach ($product_fields['commerce_product'] as $key => $value) {
          foreach ($value['display'] as $product_extra_field_name => $product_extra_field) {
            if ($product_extra_field['label'] == t('Registration')) {
              $tempfield = &$info[$entity_type][$bundle_name]['display']['product:' . $product_extra_field_name]['display'];
              foreach ($tempfield as $display => $settings) {
                $tempfield[$display]['visible'] = FALSE;
              }
            }
          }
        }
        // Loop through all field instances on products, and if each field is a
        // registration, hide it.
        foreach (field_info_instances('commerce_product') as $product_bundle_name => $product_fields) {
          foreach ($product_fields as $product_field_name => $product_field) {
            if ($product_field['label'] == t('Registration')) {
              $info[$entity_type][$bundle_name]['display']['product:' . $product_field_name]['configurable'] = FALSE;
              $info[$entity_type][$bundle_name]['display']['product:' . $product_field_name]['visible'] = FALSE;
            }
          }
        }
      }
    }
  }
}

/**
 * Implements hook_commerce_checkout_complete().
 */
function commerce_registration_commerce_checkout_complete($order) {
  if (isset($order->data['register_entities'])) {
    foreach ($order->data['register_entities'] as $product => $entities) {
      foreach ($entities as $entity) {
        registration_save($entity);
      }
    }
  }
}
